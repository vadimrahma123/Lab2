### Отчёт по лабораторной работе № 2

#### № группы: `ПМ-2502`

#### Выполнил: `Рахматуллин Вадим Тимурович`

#### Вариант: `17`

---
### Содержание
- [Задание 1](#задание-1)
  - [1. Постановка задачи](#1-постановка-задачи)
  - [2. Входные и выходные данные](#2-входные-и-выходные-данные)
  - [3. Выбор структуры данных](#3-выбор-структуры-данных)
  - [4. Алгоритм](#4-алгоритм)
  - [5. Программа](#5-программа)
  - [6. Анализ правильности решения](#6-анализ-правильности-решения)
- [Задание 2](#задание-2)
  - [1. Постановка задачи](#1-постановка-задачи-1)
  - [2. Входные и выходные данные](#2-входные-и-выходные-данные-1)
  - [3. Выбор структуры данных](#3-выбор-структуры-данных-1)
  - [4. Алгоритм](#4-алгоритм-1)
  - [5. Программа](#5-программа-1)
  - [6. Анализ правильности решения](#6-анализ-правильности-решения-1)
- [Задание 3](#задание-3)
  - [1. Постановка задачи](#1-постановка-задачи-2)
  - [2. Входные и выходные данные](#2-входные-и-выходные-данные-2)
  - [3. Выбор структуры данных](#3-выбор-структуры-данных-2)
  - [4. Алгоритм](#4-алгоритм-2)
  - [5. Программа](#5-программа-2)
  - [6. Анализ правильности решения](#6-анализ-правильности-решения-2)
- [Задание 4](#задание-4)
  - [1. Постановка задачи](#1-постановка-задачи-3)
  - [2. Входные и выходные данные](#2-входные-и-выходные-данные-3)
  - [3. Выбор структуры данных](#3-выбор-структуры-данных-3)
  - [4. Алгоритм](#4-алгоритм-3)
  - [5. Программа](#5-программа-3)
  - [6. Анализ правильности решения](#6-анализ-правильности-решения-3)
  - 
---

## Задание 1

### 1. Постановка задачи

- **Условие задачи**

>Ваша задача – посмотреть, какие значения принимает последовательность при разных a0 и n, вывести закономерность, по которой строится последовательность и запрограммировать ее самостоятельно.
>Ограничение сверху на n – искусственное, чтобы не упал весь сайт (а вы можете выбрать любое разумное ограничение самостоятельно). Если на ваш запрос сервер пятисотит (HTTP 500), значит ваша >последовательность быстро растет, и питон сломался обрабатывать ее элементы, попробуйте вывести еще меньше элементов.

- Для того чтобы вывести закономерность будем вводить разные `a0` и `n`
и изучим получившуюся последовательность.
  - Найдём зависимость от `n`. Для нулевого члена `a0` зададим
  фиксированное число 2.    
  В качестве `n` зададим число 10. Получим
  последовательность:
      ```
      a0 = 2
      n = 10
      -4, -1, 2, 5, -10, -7, 14, 17, -34, -31
      ```

    Прослеживается следующая зависимость. Нечётные элементы на 3 больше
  предыдущего, а чётные элементы отличны от предыдущего в -2 раза.  
  Теперь,
  пусть `a0 = 5` - составное число.
    ```
    a0 = 5
    n = 8
    -10, -7, 14, 17, -34, -31, 62, 65
    ```
    Получим такую же закономерность.   

    Зависимость та же. Таким образом, зависимости от чисел `a0` и `n`
  нет. Число `a0` лишь задаёт начальное значение для последовательности


### 2. Входные и выходные данные

-  #### **Данные на вход**

На вход поступают два числа: `a0` и `n`, принадлежащих, соответственно,
числовым множествам `Z` и `N`.

| Число |  Тип  | Нижняя граница |Верхняя граница |
|-------|-------|----------------|----------------|
| a0    |   Z   | -2<sup>31<sup> |2<sup>31</sup>-1|
| n     |   N   | 1              |2<sup>31</sup>-1|

- #### **Данные на выход**

Программа будет строить последовательность, которую будем хранить в
списке `l`.


### 3. Выбор структуры данных

Числа на вход будем хранить в переменной int, так как числа `a0` и `n`
принадлежат множествам целых и натуральных чисел соответственно.

| Число | Название переменной | Тип переменной |
|-------|---------------------|----------------|
| a0    | a0                  | int            |
| n     | n                   | int            |

Результатом программы будет список, хранящий, целые числа

| Объект | Название переменной | Тип переменной |
|--------|---------------------|----------------|
| l      | l                   | int            |


### 4. Алгоритм

1. Вход данных:     
    Программа на вход получает числа `a0` и `n`.

2. Проверка на ограничение:   
    Если `n` меньше 1, то выводим ошибку и завершаем программу.

3. Создаём массив `l` и заполняем его с помощью цикла по следующему
правилу. Если индекс элемента чётный, то прибаляем 3. Иначе умножаем на -2.

4. Вывод на экран:   
    Используя цикл, выводим массив `l` на экран.


### 5. Программа

```java
import java.util.Scanner;
public class laba2 {
    public static Scanner in = new Scanner(System.in);
    public static void main(String[] args){
        int a0 = in.nextInt(); // нулевой эл последовательности
        int n = in.nextInt();  // кол-во элементов последовательности
        int [] l = new int[n]; // массив, куда сохраняет последовательность

        if (n<1){
            System.out.println("длинна последовательности должна быть более 1");
            return;
        }

        for (int i = 1; i < n+1; i++) {
            if (i % 2 == 0){
                a0 += 3;
            }else {
                a0 *= -2;
            }
            l[i-1] = a0;    // ставим на i-1 позицию, т.к
        }

        for (int i = 0; i < n; i++) {       // выводим на экран
            System.out.print(l[i] + " ");
        }
    }
}
```

### 6. Анализ правильности решения

1. Тест для `a0 = 3` и `n = 8`
```
Вывод:
-6, -3, 6, 9, -18, -15, 30, 33
```

2. Тест для `a0 = 4` и `n = 9`
```
Вывод:
-8, -5, 10, 13, -26, -23, 46, 49, -98
```

3. Тест для `a0 = -5` и `n = 11`
```
Вывод:
10, 13, -26, -23, 46, 49, -98, -95, 190, 193, -386
```

4. Тест на ограничение для `n`
```
Ввод:
-5 0
Вывод:
длинна последовательности должна быть более 1
```


## Задание 2

### 1. Постановка задачи

- **Условие задачи**
>Среди натуральных чисел, не превышающих 10^9, найдите количество чисел, соответствующих маске “3*5?1”, которые делятся на 11 и у которых разность между суммой цифр на нечетных и четных позициях >оканчивается на ту же цифру, что и само число.

"?" заменяет ровно одну любую цифру

"*" заменяет последовательность цифр любой длины (включая пустую последовательность)

-Задача: Найти сколько чисел ≤ 10⁹ вида 3*5?1 делятся на 11 и у которых разность сумм цифр на нечётных и чётных позициях оканчивается на 1.

-План решения:
    Перебрать все числа по маске:
        Число = 3 + (блок A длины 0-5 цифр) + 5 + (одна цифра Q) + 1
    Двойная проверка для каждого числа:
        Делится ли на 11
        Разность сумм цифр на нечётных/чётных позициях оканчивается на 1
- Также для решения здачи мы будем использовать String.format. Но он работает только если длинна блока != 0.  
### 2. Входные и выходные данные

**Данные на вход**


| Число |  Тип   | Нижняя граница |Верхняя граница |
|-------|--------|----------------|----------------|
| n     |   N    | 1              |10<sup>9</sup>|

**Данные на выход**

Количество чисел, подходящих маске.

### 3. Выбор структуры данных

На вход программа получает целые и натуральные числа, Для их хранения
достаточно использовать тип данных `int`.  

| Объект | Название переменной                        | Тип переменной |
|--------|--------------------------------------------|----------------|
|  числа | a                                          |       long     |
|  цирфы | q                                          |       int      |


Для подсчёта числа элементов, подходящих под маску будет использовать целочисленную переменную `cnt`.

| Объект   | Название переменной | Тип переменной |
|----------|---------------------|----------------|
| cnt      | cnt                 | int            |


### 4. Алгоритм

  - Перебор всех чисел по маске "3*5?1":

  1. Перебираем длину блока * от 0 до 5 (чтобы число ≤ 10⁹)
  2. Для каждой длины перебираем все числа этого блока (с ведущими нулями)
  3. Перебираем цифру ? от 0 до 9
  4. Собираем число в строку

  - Фильтрация:
  
  1. Пропускаем числа > 10⁹
  2. Проверяем делимость на 11
  3. Вычисляем сумму цифр на чётных и нечётных позициях
  4. Находим разность сумм
  5. Проверяем, что последняя цифра разности совпадает с последней цифрой числа
  Подсчёт:

  - Увеличиваем счётчик для чисел, прошедших все проверки

### 5. Программа

```java
public class laba2 {
    public static void main(String[] args) {
        int cnt = 0;
        for (int len = 0; len <= 5; len++) {     // len - сколько цифр между 3 и 5
            long max = (long) Math.pow(10, len);    // всего вар. для блока длинны len

            for (long a = 0; a < max; a++) {        // перебор всех чисел из блока
                for (int q = 0; q < 10; q++) {      // перебор цирф 0-9

                    String block;
                    if (len == 0){      // если len == 0, то к строке нелья применить String format
                        block = "";
                    }else {
                        block = String.format("%0" + len + "d", a);
                    }
                    String numstr = "3" + block + "5" + q + "1";   // Собираем число
                    long num = Long.parseLong(numstr);      // преобразуем строку в число типа long

                    if (num > 1_000_000_000L) continue;     // провека ограничеия

                    if (num % 11 != 0) continue;  // первое условие

                    int sumch = 0;
                    int sumnch = 0;
                    for (int i = 0; i < numstr.length(); i++) {     // считаем разность сумм цифр
                        int d = numstr.charAt(i) - '0';
                        if (i % 2 == 0){        //проверка на чет и нечет
                            sumch += d;
                        } else{
                            sumnch += d;
                        }
                    }

                    int diff = sumch - sumnch;      // разница
                    int lnum = (int)(num % 10);
                    int ldiff = diff % 10;
                    if (ldiff < 0) ldiff += 10;

                    if (ldiff == lnum) cnt+= 1;
                }
            }
        }

        System.out.println(cnt);
    }
}
```

### 6. Анализ правильности решения

1. Тест программы:
```
19917
```

## Задание 3

### 1. Постановка задачи

- Условие задачи
>Дано положительное число n. Определить, существует ли в нем цифра, которая “уравновешивает” число: сумма цифр слева от нее равна сумме цифр справа. Если такая цифра есть – вывести её значение и позицию (слева направо, >начиная с 1). Если нет – вывести "NO".
>
>Формат ввода
    >одно натуральное число n

  - Преобразование числа в массив цифр:
  Число считываем как строку (чтобы сохранить ведущие нули, если они важны)
  Каждый символ преобразуем в цифру
  Перебор всех возможных "уравновешивающих" позиций:
  Для каждой позиции pos от 0 до (длина-1)
  Слева от pos: сумма цифр с индексами 0..pos-1
  Справа от pos: сумма цифр с индексами pos+1..конец

  -Проверка условия:
  Если сумма_слева == сумма_справа → цифра на позиции pos уравновешивает число
  Выводим эту цифру и номер позиции (начиная с 1)
  Завершаем поиск (по условию задачи — найти первую такую цифру)
  - Если не нашли: Выводим "NO"

### 2. Входные и выходные данные

**Данные на вход**

| Число |  Тип   |Нижняя граница| Верхняя граница  |
|-------|--------|--------------|------------------|
| n     |   N    |      1       |  31 622 776      |

**Данные на выход**


| Число     |  Тип   |Нижняя граница| Верхняя граница |
|-----------|--------|--------------|-----------------|
| значение  |   N    |      1       |   31 622 776    |
| позиция   |   N    |      1       |   31 622 776    |


### 3. Выбор структуры данных

Числа изначально будут храниться в формате String, так как нужно разбивать эти числа по разрядом, а это лего сделать из формата String.

| Число | Название переменной | Тип переменной |
|-------|---------------------|----------------|
| n     | n_str               | String         |

### 4. Алгоритм

**Поиск цифры, уравновешивающей число.**

- Смысл метода в том, чтобы за один проход по числу проверить все возможные позиции "точки равновесия". Мы используем массив цифр `digits`, где храним каждую цифру числа отдельно. Переменная `ok` служит флагом: найдена ли уравновешивающая цифра.

- Для каждой позиции `pos` от 0 до последней цифры мы вычисляем две суммы: `left` — сумма цифр левее `pos`, и `right` — сумма цифр правее pos. Если `left` == `right`, значит цифра на позиции pos уравновешивает число.

-Важное замечание: цифра в позиции `pos` не включается ни в левую, ни в правую сумму — она выступает как "точка опоры". Если такие суммы равны, мы выводим значение цифры и её порядковый номер (начиная с 1), а затем завершаем поиск.

-Если после проверки всех позиций ни одна не удовлетворила условию, выводится "NO". Это значит, что для данного числа не существует цифры, которая разделяла бы его на две части с равными суммами цифр.
  
### 5. Программа

```java
import java.util.Scanner;
public class laba2 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String nstr = in.next();

        int len = nstr.length();       // длинна числа
        int[] digits = new int[len];       // массив для цифр
        for (int i = 0; i < len; i++) {     // заполенения масива
            digits[i] = nstr.charAt(i) - '0';
        }

        boolean ok = false;     // флаг уравновешивания
        for (int pos = 0; pos < len; pos++) {
            int left = 0;       //  сумма цифр слева от текущей позиции
            int right = 0;      // сумма цифр справа от текущей позиции

            for (int i = 0; i < pos; i++) {     // сумма цифр слева
                left += digits[i];
            }
            for (int i = pos + 1; i < len; i++) {   // сумма цифр справа
                right += digits[i];
            }

            if (left == right) {        // проверка "уравновешивания"
                System.out.println(digits[pos] + " " + (pos + 1));      // значение и позиция
                ok = true;
                break;
            }
        }

        if (!ok) {      // если не нашлось такой цифры
            System.out.println("NO");
        }
    }
}

```

### 6. Анализ правильности решения

1. Пример где такой цифры не существует.
```
Ввод:
12345
Вывод:
NO
```

2. Возьмём число, где существует такая цифра.
```
Ввод:
12345654321
Вывод:
6 6
```


## Задание 4

### 1. Постановка задачи

- **Условие задачи**
>Дан массив из n чисел. Найти количество элементов, которые строго больше всех элементов, стоящих справа от них.
>Формат ввода
    >первая строка: число n
    >вторая строка: n элементов массива

- Нам достаточно ввести "флаг", который будем менять на false, если при переборе всех элементов, справа от текущего мы найдём элемент, который >= текущего. Тогда вы закончим цикл перебора эл-ов.
- в конце нам достаточно проверить флаг, и его значение равняется true, тогда счётчик будем увеличивать на 1.

### 2. Входные и выходные данные

**Данные на вход**

На вход паступает натуральное число `n`, а также `n` целых чисел `a_n` -
элементы массива `arr`.

| Число | Тип | Нижняя граница  |Верхняя граница |
|-------|-----|-----------------|----------------|
| n     | N   | 1               |2<sup>31</sup>-1|
| a_n   | N   | 1               |2<sup>31</sup>-1|


**Данные на выход**

Программа будет выводить сообщения `NO`, а также индексы элементов
массива, если условие задачи выполняются.

| Число | Тип | Нижняя граница | Верхняя граница |
|-------|-----|----------------|-----------------|
| cnt   | N   | 0              | n               |


### 3. Выбор структуры данных

Натуральные числа `n` и `k` будем хранить в одноимённых переменных типа `int`.

Элементы массива будет хранить в целочисленном `int[]` массиве `arr`.

| Объект | Название переменной               | Тип переменной |
|--------|-----------------------------------|----------------|
| n      | n                                 | int            |
| a_n    | a_n                               | int            |
| arr    | arr                               | int[]          |
| bigger | bigger                            | boolean        |


### 4. Алгоритм

-Ввод:
Считываем число n — количество элементов в массиве.
Создаём массив arr размером n.
Заполняем массив числами из ввода.

-Основной алгоритм
Идём по массиву слева направо, проверяя каждый элемент:
Для каждого элемента arr[i] (где i от 0 до n-1):
Устанавливаем флаг bigger = true (предполагаем, что текущий элемент больше всех справа).
Запускаем внутренний цикл, который проходит по всем элементам справа от i:
Для каждого j от i+1 до n-1:
Если arr[i] <= arr[j] (текущий элемент НЕ строго больше правого):
Меняем флаг bigger = false (элемент не подходит).
Прерываем внутренний цикл (break), так как дальше проверять бессмысленно.
После проверки всех правых элементов:
Если флаг bigger остался true (ни один правый элемент не был больше или равен текущему):
Увеличиваем счётчик подходящих элементов на 1.

### 5. Программа

```java
import java.util.Scanner;
public class laba2 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();       // колво элементов в массиве
        int[] arr = new int[n];     // масив

        for (int i = 0; i < n; i++) {       // заполняем масив
            int a_n = in.nextInt();
            arr[i] = a_n;
        }
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            boolean bigger = true;      // флаг является ли эл больше всех справа

            for (int j = i + 1; j < n; j++) {       //  все элементы справа от текущего
                if (arr[i] <= arr[j]) {         // Если эл справа, который не меньше текущего
                    bigger = false;
                    break;
                }
            }
            if (bigger) {        // Если после проверки всех правых элементов isGreater остался true
                cnt++;
            }
        }
        System.out.println(cnt-1);
    }
}
```

### 6. Анализ правильности решения

1. Обычный случай:
```
Ввод:
5
5 3 4 2 1
Вывод:
3
```

2. Убывающий массив:
```
Ввод:
4
4 3 2 1
Вывод:
0
```

3. Возрастающий массив:
```
Ввод:
4
1 2 3 4
Вывод:
0
```





